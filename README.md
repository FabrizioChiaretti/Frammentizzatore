# Frammentizzatore
**Frammentizzatore** is a tool written in Python intercepting the local IPv6 outbound traffic and applying a custom fragmentation. It gives also the possibility to modify the extension headers chain of intercepted IPv6 packets and to add new extension headers in order to create a new chain of headers.    

## Getting Started

### Prerequisites
The tool can be run on a Linux machine and it is required to install version 3 of Python. The external dependencies to download are:

- NetfilterQueue ([https://pypi.org/project/NetfilterQueue/]), that provides to a user space program to access to packets matched by an iptables rule in Linux;

- Scapy ([https://scapy.readthedocs.io/en/latest/]), that is a Python program that enables to send, sniff, and manipulate network packets.

### Installation and set up
In order to install the tool the following steps are required:

- Create a directory  
`
mkdir mydir
`
- Go into the new directory  
`
cd mydir
`
- Initialize an empty repository  
`
git init
`  
- Clone the repository  
`
git clone [https://github.com/FabrizioChiaretti/Frammentizzatore.git]
`
- Execute the runner.py program located in Frammentizzatore directory as root user    
`
cd Frammentizzatore
`  
`
sudo -E python3 runner.py
`  

When the tool is runnning info logs are shown on command line

![Screenshot 2024-11-11 160928](https://github.com/user-attachments/assets/60b01848-c715-4ac5-9fc1-d61c502de9c7)

Type **Ctrl**`+`**c**  for stopping the program 

![Screenshot 2024-11-11 160816](https://github.com/user-attachments/assets/dcb41753-c42e-4e46-9d3f-9fd040031796)

When the tool is running it waits untill IPv6 packets are generated by the host.

## Usage
The tool can be configured by filling the records of the **input.json** file. The following records define when, how and which IPv6 packets are intercepted and processed by the program:  

- **table**  
MANGLE  
FILTER  
Empty string stands for FILTER (default)
- **chain**  
POSTROUTING/OUTPUT for mangle table  
OUTPUT for filter table 
- **protocol**  
TCP UDP ICMPv6 ESP AH  (any combination)  
Empty string stands for TCP UDP ICMPv6 (default)
- **dstPort**  
Integer number between 0-65535 when protocol is either TCP or UDP or both  
Negative number stands for any port (default)  
- **ipv6Dest**  
IPv6 address of the receiver of the packets  
Empty string stands for any IPv6 address (default)

According to the values of the above records, new rules are added on the **ip6tables** module of the Linux kernel and all the packets matching one of these rules are intercepted and manipulated by the tool according to its configuration.  

Example

![Screenshot 2024-09-07 164801](https://github.com/user-attachments/assets/dc0d2814-28b6-43ba-95c5-fda871c524a3)

![Screenshot 2024-09-07 165113](https://github.com/user-attachments/assets/b849bbc5-d205-40e8-882c-a7c406cc88ba)

Once the IPv6 flow of the packets to be manipulated have been specified, the user has to specify the type of fragmentation to apply to the packets belonging to this flow. This is the purpose of the **type** record:
- "*Regular*" fragmentation stands for the usual fragmentation that is applied to packets by an operating system. The user can just specify the size of each fragment (except the last one) by the **fragmentSize** record (1280 is the maximum size supported).  
If the fragment size is not big enough so that the whole extension headers chain can not be located in the first fragment, the tool returns an error and the original packet that should be fragmented is released.

- "*Overlapping*" fragmentation refers to a custom fragmentation. By **fragments** record, the user can specify for each fragment the following features:
  - the source IP address of the IPv6 header (**src**),
  - the destination IP address of the IPv6 header (**dst**),
  - the lenght of the portion of the original packet payload to be carried (**PayloadLenght**),
  - the value of the hop limit field (**HopLimit**),
  - the value of the "More Fragment" flag (**M**),
  - (optionally) the indexes of the chunk of bytes to be carried (**indexes**),
  -  the values of fragment offset (**FO**) and the leght of the orginal payload to be carries by the current fragment (**PayloadLenght**). Since the fragment offset is expressed in 8-octets, these values must be positive integers and multiples of 8, therefore the tool does not use the 8-octects notation.
  - the value o the "*More fragment*" flag. For the fragment having **M** flag set to 0 (the last fragment), the value of **PayloadLenght** can be whatever positive number or negative number: in the first case the original payload will be potentially truncated and in the second case the last index of the chunk carried by the fragment is the index of the last byte of the original payload.
  - the **payload** to be carried by the current fragment, therefore in this case the original payload will be modified. In particular the payload can be just a letter and it is replicated in the payload in order to fill the fragment untill the specified lenght is achieved.

By default, when fragments overlap, each permutation of the fragments is sent to the destination, therefore the fragments are sent multiple times in a different order. The user can perform a single test by setting the **singleTest** record to 1, in this case the fragments are sent just once taking into account the order specified in the **fragments** record.

- "*Headerchain*" type provides to the user the possibility to modify or define the IPv6 extension headers chain of intercepted packets. When just "headerchain" is specified, the user can modify the order of the extension headers of the original packets and add new extension headers.
This option can be combined with overlapping fragmentation and regular fragmentation, therefore "*Overlapping-Headerchain*" and "*Regular-Headerchain*" fragmentation types are supported. They allow the user to manipulate the extension headers chain of each fragment by specifying the names of the extensions headers in the **HeaderChain** field of the **fragments** record.
The extension headers that can be added to packets are Hop-by-Hop Option header, Routing header, Destination Option header and Fragment header (also repetitions of them). Authentication header (AH) and Encapsulating Security Payload (ESP) can not be added, but when they are already located in the intercepted packets, they can be specified in the **HeaderChain** field. For each extension header, the user can specify the value of "*Next Header" field. The default value is *-1* and in that case the tool will choose an appropriate value to insert in the "Next Header" field of the specified extension header.
If the user choose "*Headerchain*" type, it is required to add just an item in the **fragments** record and when the user choose "*Regular-Headerchain*" type it is required to add an item in the **fragments** record for each fragment that will be created by the tool.

Example on how to specify the extension headers chain of a fragment
![Screenshot 2024-11-11 164856](https://github.com/user-attachments/assets/012311cd-d05a-4fc0-b3e7-dcfcc6fd4cd7)

When *tcp* is specified in **protocol** field and **type** field is set to either "*Headerchain*" or "*Overlapping*" or "*Overlapping-Headerchain*", the tool provides the possibility to the user to apply fragmentation and/or extension headers chain manipulation of the *tcp hanshake* traffic and *tcp Acknowledgement* packets. Therefore, when manipulating TCP traffic, the tool apply the manipulation of the *tcp handshake* traffic and *tcp Acknowledgement* packets according to **tcp_handshake** record and all the other TCP traffic is manipulated according to **fragments** record.  

The user finds an example of "*Overlapping-Headerchain*" fragmentation type in the **input.json** file when downloading the project.
















